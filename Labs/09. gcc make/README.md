# Лабораторная работа 9. Набор инструментов разработчика GNU Toolchain, Makefile, ELF

## Введение

Часто, во время изучения языков программирования, студенту предлагается установить какую-либо программу: Code::Blocks или Microsoft Visual Studio для языков C/C++/C\# или IntelliJ IDEA для java.

Данные программы называются IDE (*Integrated development environment* – интегрированная среда разработки) и являются инструментом, позволяющим разрабатывать огромные проекты наподобие многофункциональных графических редакторов или 3D-игр. Несмотря на то, что проекты, реализуемые при изучении языков программирования, весьма просты, и данные программы в общем-то не нужны, их предлагают установить, т.к. они позволяют с лёгкостью собирать и отлаживать проект, оставив на пользователя лишь заботу о написании кода. Это очень упрощает изучение языка на начальных этапах, однако оказывает медвежью услугу, поскольку будущий разработчик программ не понимает процессов, стоящих за нажатием кнопки `Run`.

Зачем вообще может понадобиться знание об этих процессах? Например, для кросс-компиляции. Разрабатывая программу для микроконтроллера или системы на кристалле, необходимо компилировать исходный код на рабочем компьютере, однако собранный код будет запускаться на устройстве с другой архитектурой. Код, скомпилированный под одну архитектуру не сможет работать на другой. Компиляция исходного кода на компьютере с одной архитектурой для запуска на компьютере с другой архитектурой и называется кросс-компиляцией. Распространённые IDE не используются в кросс-компиляции, необходимо использовать среды, написанные под какие-то конкретные семейства микроконтроллеров, в связи с чем, нет особого выбора. Для новичка, поиск материалов по настройке и реализации проекта не на микроконтроллерах Arduino и STM32 может вылиться в проблему, не говоря о том, что большинство материалов могут оказаться устаревшими или не совсем подходящими. В такие моменты можно прийти к выводу, что скомпилировать проект, используя один лишь кросс-компилятор будет проще. Кроме того, такой подход позволит работать на разных операционных системах и аппаратных платформах, используя инструменты сборки с открытыми исходными кодами (например, gcc).

Кроме того, в связи со своим мощным функционалом, популярные IDE, как правило, ресурсоёмки и не походят для запуска, компиляции и отладки на низкопроизводительных компьютерах или ноутбуках. Код можно редактировать и в легковесных редакторах, а сборку и отладку можно выполнять из терминала.

Таким образом, хорошему разработчику нужно уметь не только писать код, но и уметь его собирать.

## Hello World

Традиционно, любой курс начинается с примера `Hello World`. В листинге ниже приведена простейшая программа, которую можно написать в любом текстовом редакторе, и собрать её из терминала.

```c
#include <stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
```

Для её сборки, необходимо открыть терминал, указав рабочей директорией папку с данным файлом, после чего выполнить следующую команду:

```shell
gcc hello.c
```

Результатом её выполнения в операционной системе Windows станет исполняемый файл a.exe. При запуске файл выведет строку `Hello, world!` в окно текстового терминала. Процедура вышла весьма простой, однако лишь потому, что это упрощённый пример, и в реальных проектах процесс сборки сложнее.

Что же произошло во время выполнения этой команды?

В первую очередь, надо разобраться с тем, что такое gcc.

## Что такое GCC

Изначально, GNU C Compiler, был разработан Ричардом Столлманом, основателем GNU Project. С течением времени, GCC развивался и стал поддерживать множество языков: C (gcc), C++ (g++), Objective-C, Objective-C++, Java (gcj), Fortran (gfortran), Ada (gnat), Go (gccgo), OpenMP, Cilk Plus, и OpenAcc, поэтому теперь GCC расшифровывается как GNU Compiler Collection.

GCC – ключевой компонент так называемого GNU Toolchain, предназначенного для разработки приложений и операционных систем. Он включает:

  - GNU Compiler Collection (GCC) – набор компиляторов, поддерживающий множество языков, например: C/C++ and Objective-C/C++;
  - GNU Make – средство автоматизации для компиляции и сборки приложений;
  - GNU Binutils – набор утилит, включающий компоновщик и транслятор;
  - GNU Debugger (GDB) – средство отладки программ;
  - GNU Autotools – система сборки, включающая: Autoconf, Autoheader, Automake и Libtool;
  - GNU Bison: генератор синтаксических анализаторов (похож на lex и yacc).

Прямо сейчас интерес представляет сам GCC, а также Binutils, в дальнейшем, будут разобраны Make и GDB.

## Поэтапный разбор процесса компиляции

За употребляемым в среде программистов словом ``компиляция'' обычно стоят четыре последовательных этапа, показанные на рисунке:

![Этапы компиляции программы.](./pic/pic1.png)

### Предобработка

Предобработка исходного кода выполняется препроцессором. Его работа заключается во вставке содержимого файлов, подключённых с помощью директивы `#include`, а также подстановке значений в макросах, определённых директивой `#define`. Результатом его работы является изначальный исходный код, но включающий все вставки и замены.

### Компиляция

Компиляция переводит исходный код в набор машинных инструкций на языке ассемблера. Набор таких инструкций различается между архитектурами и именно это является причиной того, что код, скомпилированный под одну архитектуру, нельзя запустить на другой. Результатом работы компилятора является код на языке ассемблера.

### Трансляция

Ассемблер (транслятор) переводит код на языке ассемблера в машинный – набор нулей и единиц, который, однако, ещё не получится запустить – для этого необходимо разрешить связи между функциями и переменными (или символами) программы.

### Компоновка

Линковщик (компоновщик) устанавливает связи между вызовами функций в основном коде программы и реализацией этих функций в подключаемых библиотеках.
Далее будет подробно рассмотрен процесс сборки примера ``Hello world''.
Сперва запускается препроцессор (исполняемый файл cpp.exe), который подключает заголовочные файлы и раскрывает макросы. Результат сохраняется в промежуточный файл .i в виде раскрытого исходного кода:

\begin{minted}[linenos=false]{bash}

```shell
cpp hello.c > hello.i
```

В данной команде, > означает перенаправление потока вывода в файл `hello.i`. Оно необходимо, поскольку по умолчанию, результат работы препроцессора будет направлен в стандартный поток вывода (в большинстве случаев, терминал, из которого запущена программа). Т.е. будет лишь выведен результат работы, но он не будет сохранен в файл. Того же самого можно добиться, заменив `>` на `-o` (подробнее опция `-o` будет рассмотрена далее).
Затем, происходит компиляция исходного кода в код на языке ассемблера, специфичный для конкретного процессора. За это отвечает программа `gcc`:

```shell
gcc -S hello.i
```

опция `-S` говорит остановиться после выполнения этапа компиляции, поскольку этой же программой можно выполнить все четыре этапа сразу, как было показано в первом примере.

Далее, происходит трансляция этого кода в машинный код, который помещается в объектный файл `hello.o`:

```shell
as -o hello.o hello.s
```

Опция `-o` указывает, какое имя файла должно получиться на выходе. Если она не указана, именем исполняемого/объектного файла будет `a.out`, а промежуточные файлы других этапов будут названы так же, как и поданный на вход файл, с изменённым суффиксом.
Наконец, компоновщик `ld` связывает объектный код с кодом библиотек, производя исполняемый файл `hello`.

```shell
ld -o hello hello.o ...libraries...
```

Полная версия команды не указана, т.к. вместо libraries необходимо указать весь список библиотек (как правило, весьма объёмный), который необходим для работы программы.

Чтобы все-таки собрать проект, проще воспользоваться самим `gcc`, который затем автоматически вызовет компоновщик со всеми необходимыми параметрами:

```shell
gcc -o hello.exe hello.o
```

Если всё же возникла необходимость произвести компоновку самостоятельно, можно воспользоваться следующим способом для получения полного списка библиотек:
К команде вызова `gcc` необходимо добавить:

```shell
2> log.txt
```

Данная конструкция направит поток вывода в файл `log.txt`, внутри которого можно будет увидеть команды, которые выполнял компилятор. Надо найти строку:

```shell
COLLECT_GCC_OPTIONS
```

Под этой строкой необходимо найти место, где закончатся перечисления плагинов и пойдут перечисления объектных файлов и ключи `-L` – это и есть необходимые для компоновщика опции.

Если передать компилятору опцию `-save-temps`, тот сохранит промежуточные файлы каждого из выполненных этапов. Для интереса, можете посмотреть на результат работы препроцессора и компилятора (файлы `.i`/`.ii`, `.s` соответственно).

## Компиляция кода из нескольких файлов

В реальных проектах, код не пишется в одном единственном файле, классы и функции выносятся в отдельные файлы, которые потом могут собираться в библиотеки.

Ниже приведён пример проекта, использующего собственную функцию. Обычно, прототип функции описывается в файле `.h`, а её реализация – в файле с расширением `.c`. Файлы с расширением `.h` (заголовочные файлы) , как правило, поставляются с прекомпилированными библиотеками и как бы представляют её функционал и интерфейс, но не реализацию.

Часто заголовочные файлы и файлы исходного кода разделяются по папкам `inc` и `src` соответственно. Таким образом, создадим проект со следующей структурой:

```
Hello_project
  inc
    hello.h
  src
    hello.c
    main.c
```

В папке с проектом находятся папки `inc` и `src`, в которых находятся `hello.h` и `hello.c`, `main.c` соответственно. Содержимое этих файлов показано в листингах ниже.

Содержимое файла `hello.h`:

```c
#include <stdio.h>
void hello_world (void);
```

Содержимое файла `hello.c`:

```c
#include "hello.h"
void hello_world(void)
{
    printf("Hello World!");
}
```

Содержимое файла `main.c`:

```c
#include "hello.h"

int main() {
    hello_world();
    return 0;
}
```

Из этих трёх файлов скомпилировать надо два (заголовочный файл будет вставлен в остальные препроцессором). Сделать это можно из папки проекта командой:

```shell
gcc -c src/hello.c src/main.c -Iinc
```

Важно, что при вызове компилятора необходимо указывать полный путь до компилируемых файлов.

Ранее уже было сказано, что gcc последовательно вызывает препроцессор, компилятор, транслятор и компоновщик. Можно сообщить ему, на каком из этапов нужно остановиться с помощью специальных опций(ключей), переданных в команде:

  -	`-E` – остановиться после этапа предобработки;
  -	`-S` – остановиться после этапа компиляции;
  -	`-c` – остановиться после этапа трансляции.

Ключ `-I` (сокращение от Include) указывает компилятору, где искать подключаемые файлы. В переменных среды есть стандартные пути, поиска, поэтому нам не нужно искать, где находится заголовочный файл `stdio.h`. Кроме того, стоит заметить, что директории, указанные через данный ключ, обладают более высоким приоритетом, т.е. компилятор будет искать подключаемые файлы сначала в них, и если там будет заголовочный файл, одноименный с `stdio.h`, подключится именно он. Если необходимо указать несколько папок, каждую из них нужно передавать со своим ключом. Поиск не производится рекурсивно, если нужно добавить вложенные папки, каждую из них так же надо передать через ключ `-I`.

После получения объектных файлов, их необходимо скомпоновать в исполняемый файл. Для этого, опять же, необходимо воспользоваться `gcc` (который автоматически вызовет компоновщик):

```shell
gcc -o hello hello.o main.o
```

Может возникнуть вопрос: зачем два раза вызывать `gcc`, если можно было просто убрать ключ `-c` при первом вызове. Дело в том, что при изменении любого файла, необходимо пересобрать весь проект целиком. Пересборка больших проектов (скажем, ядра Linux) – это очень долгий процесс. Разделив сборку на две части, появляется возможность скомпилировать только изменённый файл, а затем, скомпоновать заново весь проект целиком.

В данный момент вручную указывается полный путь до компилируемых файлов и все папки с заголовочными файлами. Это делается для лучшего понимания процесса. Способы упрощения этой процедуры будут описаны позднее.

## Сборка библиотеки

Пусть существует код, который будет использоваться во многих проектах. Или объём кода довольно большой, дальнейшие изменения в нём не планируются, а компиляция уже занимает весьма много времени. Или необходимо получить из вашего кода бинарный файл, чтобы, передав его человеку, не раскрывать ему реализацию (сохранить свою интеллектуальную собственность). Для всего этого можно скомпилировать код в библиотеку.

Библиотеки делятся на два типа: статические и динамические.


### Статическая библиотека


Статическая библиотека (или `архив`) состоит из подпрограмм, которые непосредственно компилируются и линкуются с программой в исполняемый файл. При компиляции программы, которая использует статическую библиотеку, весь функционал статической библиотеки (тот, что использует программа) становится частью вашего исполняемого файла. В Windows статические библиотеки имеют расширение `.lib` (от `library`), тогда как в ОС семейства GNU\Linux статические библиотеки имеют расширение `.a` (от `archive`). Примечание автора: в дальнейшем, дабы уйти от громоздкой записи *ОС семейства GNU\Linux*, будет использоваться слово *Linux* в качестве её замены. В случаях, когда в тексте будет идти речь о ядре Linux, об этом будет сказано явно.

Одним из преимуществ статических библиотек является то, что нужно распространять всего лишь один файл (исполняемый файл), дабы пользователи могли запустить и использовать программу. Поскольку статические библиотеки становятся частью программы, то можно использовать их подобно функционалу этой же самой программы. С другой стороны, поскольку копия библиотеки становится частью каждого исполняемого файла, то это может привести к увеличению его размера. Также, для того чтобы обновить статическую библиотеку, необходимо перекомпилировать каждый исполняемый файл, который её использует.

### Динамическая библиотека

Динамическая библиотека (или *общая (разделяемая) библиотека*) состоит из подпрограмм, которые подгружаются в программу во время её выполнения. При компиляции программы, которая использует динамическую библиотеку, эта библиотека не становится частью исполняемого файла — она так и остаётся отдельным модулем. В Windows динамические библиотеки имеют расширение `.dll` (от *dynamic link library* = *библиотека динамической компоновки*), тогда как в Linux динамические библиотеки имеют расширение `.so` (от *shared object* = *общий объект*). Одним из преимуществ динамических библиотек является то, что разные программы могут совместно использовать одну копию динамической библиотеки, что значительно экономит используемое пространство. Ещё одним преимуществом динамической библиотеки является то, что её можно обновлять до более новой версии без перекомпиляции всех исполняемых файлов, которые её используют.

Поскольку динамические библиотеки не линкуются непосредственно с программой, то программы, использующие динамические библиотеки, должны явно подключать и взаимодействовать с динамической библиотекой. Этот механизм не всегда может быть понятен для начинающих программистов, что может затруднить взаимодействие с динамической библиотекой. Для упрощения этого процесса используют библиотеки импорта.

Библиотека импорта (англ. *import library*) — это библиотека, которая автоматизирует процесс подключения и использования динамической библиотеки. В Windows это обычно делается через небольшую статическую библиотеку (`.lib`) с тем же именем, что и динамическая библиотека (`.dll`). Статическая библиотека линкуется с программой во время компиляции, после чего функционал динамической библиотеки может эффективно использоваться в программе, как если бы это была обычная статическая библиотека. В Linux общий объектный файл (с расширением `.so`) дублируется сразу как динамическая библиотека и библиотека импорта. Большинство компоновщиков при создании динамической библиотеки автоматически создают к ней библиотеку импорта.

### Сборка и использование статических библиотек

Ниже будет рассмотрен использовавшийся в прошлом примере проект и описан процесс компилирования файлов `hello.c` и `hello.h` статическую библиотеку:

В первую очередь, необходимо получить объектный файл файла `hello.c`:

\begin{minted}[linenos=false]{bash}

```shell
gcc -c src/hello.c -Iinc -o hello.o
```

После этого, необходимо создать статическую библиотеку, при помощи утилиты ar (ранее уже говорилось, что в Linux статические библиотеки называются архивами, а название утилиты получилось от сокращения ``archiver'' – архиватор):


```shell
ar rcs hello.lib hello.o
```

`rcs` – это опции команды, `r` – означает вставку с заменой, c – создать новый архив, `s` – записать index

Данная команда соберёт статическую библиотеку `hello.lib` из объектного файла `hello.o`.

Для того, чтобы использовать эту библиотеку при компиляции проекта, сначала необходимо скомпилировать файл `main.c`:

```shell
gcc -c src/main.c -Iinc -o main.o
```
После чего, произвести компоновку с данной библиотекой:

```shell
gcc main.o -L./ -lhello -o hello
```

Ключ `-L` указывает папку, в которой необходимо искать библиотеки (`./` является синонимом для *текущая папка*), через ключ `-l` указывается имя подключаемой библиотеки (стоит заметить, что все библиотеки в Linux собираются с префиксом `lib`: `libhello`, `libworld` и т.п., поэтому в саму опцию нужно передавать имя без этого префикса).

### Сборка и использование динамических библиотек

Объектные файлы, скомпилированные для компоновки в динамическую библиотеку, должны представлять собой *позиционно-независимый код*.

*Позиционно-независимый код* (англ. *position-independent code*) – программа, которая может быть размещена в любой области памяти, так как все ссылки на ячейки памяти в ней относительные (например, относительно счётчика команд). Такую программу можно переместить в другую область памяти в любой момент, в отличие от перемещаемой программы, которая хотя и может быть загружена в любую область памяти, но после загрузки должна оставаться на том же месте.

Вообще, тема динамических библиотек поистине обширна и заслуживает отдельной серии занятий. Здесь будут приводиться лишь некоторые крупицы информации со ссылками на более углублённые статьи.

Для того, чтобы скомпилировать объектный файл в виде позиционно-независимого кода, необходимо добавить компилятору одну из опций: `-fPIC` или `-fpic`. *PIC* – это, как нетрудно догадаться и запомнить, аббревиатура от *position-independent code*. `-fPIC` работает всегда, но даёт больший объём кода, чем `-fpic` (Запомнить это свойство можно с помощью простого мненонического правила: `PIC` *крупнее* `pic`). Применение `-fpic` обычно приводит к генерации меньшего и более быстрого кода, но он будет иметь некоторые платформенно-зависимые ограничения, например, количество глобально видимых символов или размер всего кода.

```shell
gcc -c -fpic src/hello.c -Iinc -o hello.o
```
Команда выше уже должна стать привычной, за исключением описанного ранее ключа тут не появилось ничего нового.

Далее, необходимо скомпоновать позиционно-независимый код в динамическую библиотеку:

```shell
gcc -shared hello.o -o hello.dll
```

Собрать итоговый проект можно так же, как и при использовании статической библиотеки:

```shell
gcc main.o -L./ -lhello -o hello
```

## Отладка программы

Помимо препроцессора, компилятора, транслятора и компоновщика, GNU Toolchain предоставляет средства для отладки, в частности, утилиту `gdb` (GNU Debugger).

C помощью GDB можно:

 - запустить программу с определёнными аргументами;
 - запустить программу в пошаговом режиме;
 - установить точки останова (breakpoint);
 - установить условие останова программы;
 - получить информацию о состоянии программы перед тем, как она прекратила работу из-за ошибки;
 - получить информацию о текущем состоянии стека;
 - узнать значение переменной;
 - изменить значение переменной.


Это далеко не весь список, но даже этот функционал открывает широкий спектр возможностей.

Для отладки программы необходимо, чтобы она была собрана с отладочной информацией. Для этого, при компиляции исходных кодов программы, необходимо добавить ключ -g. Необходимо иметь в виду, что при компиляции с этим ключом, размер программы значительно возрастает.

Рассмотрим программу, исходный код которой приведён в листинге ниже. Программа должна вывести первые n символов латинского алфавита.

```c
#include <stdio.h>
#include <stdlib.h>
void print_chars(int);
int main(int argc, char* argv[]){
    int a;
    if(argc == 1)
    {
      printf("Enter the number of letter that you want to see:");
      scanf("%d",&a);
    }
        else
        {
          a = *(argv[1]) - 58; // мы считаем, что ASCII-код символа ‘0’
                         // равен 58, а не 48, и не знаем,
                         // что этого можно было избежать, написав ‘0’.
        }

        print_chars(a);
        return 0;
    }

void print_chars(int num_of_chars)
{
    char *str = NULL;
    str = (char *)malloc((num_of_chars + 1) * sizeof(char));
    for (int i = 0; i < num_of_chars; ++i)
    {
      str[i] = 'a' + i;
    }
    str[num_of_chars] = '\0';
    printf("%s", str);
    free(str);
}
```

Произведён запуск программы, чтобы она вывела 5 латинских символов:


```shell
./main 5
```
```
Segmentation fault
```

Ошибка сегментации явно указывает на попытку обращения к недоступным для записи или чтения участкам памяти. Для обнаружения и исправления ошибки необходимо выполнить отладку программы.

Для начала, необходимо собрать данный файл с отладочной информацией:

```shell
gcc main.c -output main -g
```
После, запустить его в отладчике

```shell
gdb main
```

В терминале выведется длинное сообщение, сообщающее о лицензии использования `gdb`, а так же об отказе от ответственности (поскольку пользователь имеет доступ к редактированию переменных прямо во время работы программы, авторы `gdb` не могут гарантировать, что это не приведёт к негативным последствиям).

Для запуска отладчика с пропуском стартового сообщения используйте ключ `-q` (от англ.: *quiet* – тихий).

Поскольку нет никаких предположений о том, где могла возникнуть ошибка сегментации, стоит произвести тестовый запуск программы в отладчике идентичный сделанному до этого в терминале. Для запуска программы используется команда run с указанием опций, передаваемых программе:

```
run 5
```

на что gdb выведет содержимое, приблизительно соответствующее тексту ниже:

```
Starting program: main.exe 5
[New Thread 20488.0x51ac]
[New Thread 20488.0x4e74]

Program received signal SIGSEGV, Segmentation fault.
0x00000000004015b5 in print_chars (num_of_chars=-5) at src/main.c:29
29	    str[num_of_chars] = '\0';
```

В результате анализа сообщений отладчика, можно сделать следующие выводы:

  - ошибка произошла в функции `print_chars`, в частности, в строке 29;
  - выведенный стек вызовов говорит, что переданное в эту функцию значение для переменной `num_of_chars` равно -5, что отлично от ожидаемого поведения.

Прежде чем разбираться с тем, почему в функцию передаётся неверное значение, стоит изучить функцию `print_chars`. Для этого, необходимо вывести исходный код данной функции:

```
list print_chars
```

Данная команда выводит исходный код, отцентрованный относительно точки входа в функцию. Функция не уместилась за один вывод, поэтому необходимо вызвать `list` ещё раз. Будучи переданным без аргументов, он продолжит вывод исходного кода функции из предыдущего вызова `list`.


```
(gdb) list print_chars
17	    print_chars(a);
18	    return 0;
19	}
20
21	void print_chars(int num_of_chars)
22	{
23	    char *str = NULL;
24	    str = (char *)malloc((num_of_chars + 1) * sizeof(char));
25	    for (int i = 0; i < num_of_chars; ++i)
26	    {
(gdb) list
27		  str[i] = 'a' + i;
28	    }
29	    str[num_of_chars] = '\0';
30	    printf("%s", str);
31	    free(str);
32	}
33
```

Предположим, что надо установить три точки останова:

  - на входе в функцию;
  - внутри цикла for, когда итератор i больше двух;
  - на строке, вызвавшей падение программы.


Для создания точки останова, используется команда `break` (или сокращение `b`):


```
break print_chars
b 27 if i>2
b 29
```

Перезапуск программы с тем же аргументом

```
run 5
```

Будет сказано, что программа уже выполняется и нужно ли запустить её с начала. Вам нужно ответить вводом символа `y`(yes/да) или `n`(no/нет).

Будет произведён следующий вывод:

```
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: main.exe 5
[New Thread 12036.0x44c0]
[New Thread 12036.0x57ac]

Breakpoint 1, print_chars (num_of_chars=-5) at src/main.c:23
23	    char *str = NULL;
```

Для продолжения выполнения программы после точки останова используется три команды:

  - `next` (или сокращение `n`) – выполнение кода программы до следующей строчки исходного кода;
  - `step` (или сокращение `s`) – выполняет вход внутрь функции, расположенной на текущей строке. Выполнив `step` на строке 17, вы попадёте внутрь функции `print_chars`. Выполнив `step` на строке 24, вы попадёте внутрь функции `malloc`.
  - `continue` (или сокращение `c`) – выполнение кода программы до следующей точки останова, или, если таковые не встретятся, до её завершения.


Каждая из команд выше может иметь аргументы, расширяющие её функционал. Все опущенные здесь подробности можно найти в руководстве по `gdb`.

Выполнив две строчки нашей программы, можно убедиться, что вызов функции `malloc` с отрицательным размером памяти не привёл к должной инициализации строки `str`:

`n 2` – выполнить не одну, а две строчки программы

`print str` – вывести значение переменной `str` (вместо `print` можно использовать сокращение `p`)

Результатом этих команд будет:

```
23	    char *str = NULL;
(gdb) n 2
25	    for (int i = 0; i < num_of_chars; ++i)
(gdb) p str
$1 = 0x0
```

Продолжить выполнение программы до следующей точки останова:

```
c
```

Как можно увидеть, программа не остановилась внутри цикла `for`, вместо этого, остановившись на 29-ой строке. Это произошло, поскольку итератор `i`, инициализированный нулём сразу оказался больше отрицательного аргумента `num_of_char`, в связи с чем, исполнение программы не было передано внутрь цикла.

```
(gdb) c
Continuing.

Breakpoint 2, print_chars (num_of_chars=-5) at src/main.c:29
29	    str[num_of_chars] = '\0';
```

Теперь необходимо поставить точку останова c вызовом функции `print_char` и перезапустить программу:

```
(gdb) b 17
Breakpoint 3 at 0x401542: file src/main.c, line 17.
(gdb) r 5
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: C:\Users\voult\Desktop\1\hello.exe 5
[New Thread 21776.0xf54]
[New Thread 21776.0x36f4]

Breakpoint 3, main (argc=2, argv=0x7214b0) at src/main.c:17
17	    print_chars(a);
```

После, нужно изменить значение переменной a на ожидаемое и вновь зайти внутрь функции `print_chars`

```
(gdb) p a=5
$3 = 5
(gdb) step

Breakpoint 1, print_chars (num_of_chars=5) at src/main.c:23
23	    char *str = NULL;
```


Если остановиться на входе в функцию, можно увидеть, что внутрь попало изменённое значение. Считается, что теперь все пойдёт по плану, поэтому можно удалить все точки останова внутри функции `print_chars`. Удаление конкретной точки останова аналогично её установке, только вместо команды `break` используется команда `clear`. Для удаления всех точек останова, используется команда `delete`, без передачи в неё параметров. Если продолжить исполнение кода программы можно убедиться, что он выполнится без новых ошибок:

```
(gdb) delete
Delete all breakpoints? (y or n) y
(gdb) c
Continuing.
abcde[Thread 21776.0x36f4 exited with code 0]
[Inferior 1 (process 21776) exited normally]  
```


Функция `print_chars` работает корректно. Проблема заключается в неверном присвоении значения переменной `a`.

Значение переменной присваивается в строке 9, если в программу не были переданы аргументы и в строке 13, если программа была запущенна с аргументами. Необходимо исправить строчку 13 на верную:


```c
13:	a = *(argv[1]) – ‘0’;
```

Далее, необходимо сохранить исходный код, скомпилировать программу без отладочных символов.

## Автоматизация сборки проекта

### Краткое введение в make

Ранее обращалось внимание на то, что указание полного пути до каждого компилируемого файла – утомительное занятие. Проект может содержать сотни файлов, ручное указание всех этих файлов становится уже нереалистичным. Для автоматизации этого процесса в GNU Toolchain есть программа `make`.

Директивы утилиты `make` служат для определения зависимостей между файлами проекта и находятся в файле по имени `Makefile`, расположенном в каталоге сборки.

Общий формат make-файла выглядит так:


```make
цель1: зависимости
    правила
#...
цельN: зависимости
    правила  
```

Цель — это метка для некоторой последовательности команд, или результирующий файл, который нужно *построить*, например, скомпилировать или скомпоновать.

Цели должны отделяться друг от друга хотя бы одной пустой строкой. Зависимости – это перечень файлов или других целей, которые нужны для достижения данной цели; он может быть и пустым.

Правила — это последовательность команд, которую нужно выполнить для достижения цели. Правила должны отделяться от начала строки символом табуляции, иначе make завершится ошибкой  `missing separator` (нет разделителя).

В make могут использоваться так называемые фиктивные цели – это цели, результатом которых не будет одноименный файл. Часто используемые фиктивные цели в make, это:

  -	`all` – цель по умолчанию. Её зависимостями ставятся те цели, которые вы хотите обработать, при регулярном запуске make.
  -	`clean` – очистка промежуточных файлов. В процессе сборки исполняемого файла, в директории остаются объектные файлы. Цель `clean` может использоваться для их очистки.
  -	`clean_all`: полная очистка директории от продуктов работы других целей. Если цель `clean` удалит только промежуточные файлы, `clean_all` удалит всё, что было могло быть создано в процессе исполнения остальных целей из этого файла, включая исполняемые.

Для того, чтобы указать make, что подобная цель – фиктивная, необходимо указать эту цель в качестве зависимости для специальной предопределённой цели `.PHONY`: (от англ. *phony* – фальшивый):

```make
.PHONY: all clean
```

Зачем необходимы фиктивные цели? Предположим, в каталоге есть файл с именем `clean`. В таком случае, make будет обрабатывать его так же, как и остальные файлы-цели. Если дата последнего изменения файла `clean` указана более поздней, чем дата изменения его зависимостей, обработка прекращается. Если цель `clean` не зависит при этом ни от чего, или зависит лишь от других фиктивных целей, make будет считать, что цель не нуждается в обработке и прекратит работу. Цель `.PHONY` позволяет избежать подобного поведения программы.

Make-файл может содержать однострочные комментарии — они начинаются символом `#`.

make ищет файлы в следующем порядке: `GNUmakefile`, `makefile` и только потом `Makefile`. Однако, общей практикой принято использовать именно `Makefile`.

Запуск make происходит следующим образом:

```shell
make имя_цели
```

Если цель не указана, make произведет попытку сборки  первой встреченной цели. По этой причине, первой целью часто ставят цель `all`.

Если файл назван произвольным именем, для его обработки make необходимо запускать в виде:


```shell
make -f имя_файла имя_цели
```

### Пример простого Makefile

Ниже приведён пример файла `Makefile` для сборки исходного кода из раздела "Компиляция кода из нескольких файлов". Для того, чтобы собрать программу, как уже было описано ранее, необходимо два этапа: сборка бинарного файла из объектных, сборка объектных файлов из исходных.

Необходимо в корне проекта создать файл с именем `Makefile` и содержимым, приведённым в листинге ниже.

```make
hello.o: src/hello.c
    gcc -c -Iinc ./src/hello.c

main.o: src/main.c
    gcc -c -Iinc ./src/main.c

hello: main.o hello.o
    gcc -o hello main.o hello.o  
```

`hello.o`, `main.o` и `hello`, указанные в началах строк – это цели. 

Итоговая цель – сборка исполняемого файла, это цель `hello`. Данная цель зависит от целей `main.o`, `hello.o` – нельзя собрать исполняемый файл, пока не были собраны объектные. Сборка выполняется рекурсивно: make сначала выполняет все цели, от которых зависит текущая цель. Если зависимость представляет собой файл, то make сравнивает время его последней модификации со временем целевого файла: если целевой файл был изменён раньше или отсутствует, то будет выполнена указанная последовательность команд. Если целевой файл был изменён позже, то текущая цель считается достигнутой.

Далее, нужно запустить автоматическую сборку командой:

```shell
make hello
```

В результате, должны собраться объектные файлы `hello.o`, `main.o`, а так же исполняемый файл `hello`.

Make может использоваться и для более сложных вещей, в нём можно вызывать функции и команды терминала, есть несколько видов переменных, шаблонные символы и много чего другого. В следующих параграфах будет рассмотрена часть из этого функционала.
